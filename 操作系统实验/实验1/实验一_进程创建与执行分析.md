
# 实验一：进程与线程  

---

## 1.1 进程实验  

### 1.1.1 `wait` 函数  

搭建好华为云服务器后开始实验，直接提取图片代码运行。由于所给程序使用了 `wait` 函数且缺少头文件，在使用命令行编译时会报错，如图所示：  

<div align="center">
  <img width="1685" height="174" src="https://github.com/user-attachments/assets/1bcf9792-5d23-467b-ac2e-23d05e967d4d" />
  <br>缺少头文件的运行结果
</div>

不过报错并不影响程序运行。为了方便观察，我在输出中加入了换行符 `\n`，输出结果如下图：  

<div align="center">
  <img width="571" height="704" src="https://github.com/user-attachments/assets/4727eafb-6309-4f92-b41c-38862ffada5b" />
  <img width="524" height="704" src="https://github.com/user-attachments/assets/1e31b4a8-2c92-4235-9636-cb6893d52cae" />
  <br>存在换行符的情况
</div>

结果显示每次输出分为四行，易于观察，但输出顺序并不固定。  

我认为在 `wait` 函数存在时，应该是子进程先输出，再由父进程输出，如下：  

```
child: pid = 0  
child: pid1 = 4890  
parent: pid = 4890  
parent: pid1 = 4889
```

但在安装了基于 OpenEuler 的 Deepin 系统虚拟机上运行相同程序时，结果却是父进程先输出：  

<div align="center">
  <img width="526" height="684" src="https://github.com/user-attachments/assets/cee314d3-27cc-4b1e-9c15-e1f550cf22ca" />
  <img width="536" height="676" src="https://github.com/user-attachments/assets/b8e26388-a37d-462a-99bc-d1a70910f7ec" />
  <br>在虚拟机上运行
</div>

#### 输出顺序分析  

存在三种典型情况：  

1. **子进程先执行（常见）**
   ```
   child: pid = 0
   child: pid1 = 1234
   parent: pid = 1234
   parent: pid1 = 1233
   ```
2. **父进程先执行打印（然后等待子进程）**
   ```
   parent: pid = 1234
   parent: pid1 = 1233
   child: pid = 0
   child: pid1 = 1234
   ```
3. **打印交错**
   ```
   child: pid = 0
   parent: pid = 1234
   child: pid1 = 1234
   parent: pid1 = 1233
   ```

输出顺序取决于操作系统调度算法。`fork()` 创建子进程后，父、子进程并发执行，调度器根据 CPU 负载和时钟中断等随机因素决定先后。

#### 去除换行符实验  

删除换行符后的代码如下：

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid, pid1;
    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) {
        pid1 = getpid();
        printf("child: pid = %d", pid);
        printf("child: pid1 = %d", pid1);
    }
    else {
        pid1 = getpid();
        printf("parent: pid = %d", pid);
        printf("parent: pid1 = %d", pid1);
        wait(NULL);
    }
    return 0;
}
```

运行结果如下：

<div align="center">
  <img width="1455" height="317" src="https://github.com/user-attachments/assets/7ae545c1-58a6-4562-bf4d-ccef3ea02a46" />
  <br>删除 `\n` 后的运行结果
</div>

此时输出顺序稳定，符合预期。

#### 多次运行统计与分析  

多次运行结果显示：
- 子进程的 `pid` 恒为 0；
- 父进程的 `pid1` 比子进程大 1；
- 连续运行时 PID 逐次递增，差值通常为 2也有可能出现3.

原因：
- `fork()` 在子进程中返回 0；
- 父进程中 `pid = 子进程PID`；
- `getpid()` 返回当前进程实际 PID；
- 系统分配 PID 时递增，差值受其他进程创建影响。

#### 去掉 `wait()` 对比  

<div align="center">
  <img width="1476" height="282" src="https://github.com/user-attachments/assets/9c1ab1ef-8303-4083-8cb5-979be170ef3e" />
  <br>去除 `wait()` 的结果
</div>

对比后发现：
- 有 `wait()`：父进程等待子进程结束，输出顺序稳定；
- 无 `wait()`：父子并发执行，输出顺序随机，甚至父进程先退出形成孤儿进程。

---

### 1.1.2 全局变量  

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>

int g = 10;

int main() {
    pid_t pid, pid1;
    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) {
        g += 5;
        pid1 = getpid();
        printf("child: pid1 = %d, g = %d\n", pid1, g);
    }
    else {
        g -= 5;
        pid1 = getpid();
        printf("parent: pid1 = %d, g = %d\n", pid1, g);
        wait(NULL);
    }
    return 0;
}
```

运行结果稳定：  
父进程 `g = 5`，子进程 `g = 15`。  
说明 `fork()` 后父子各自维护独立的变量副本。

#### 增加返回前操作  

```c
g *= 2;
printf("pid %d: g(after *2) = %d\n", getpid(), g);
```

运行结果：  
- 子进程 `(10 + 5) * 2 = 30`  
- 父进程 `(10 - 5) * 2 = 10`  

父子进程互不影响。

---

### 1.1.3 调用外部程序  

被调用程序 `system_call.c`：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("system_call PID: %d, 我的学号: 2233514228\n", getpid());
    return 0;
}
```
<img width="878" height="90" alt="image" src="https://github.com/user-attachments/assets/9c55e609-165e-4b80-9f5b-297528a1725d" />

若输出含中文，终端编码不支持时会出现乱码。

#### 调用方式一：`system()`  

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main()
{
    pid_t pid;
    printf("parent process PID: %d\n", getpid());

    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed\n");
        return 1;
    }
    else if (pid == 0) {
        printf("child process PID: %d\n", getpid());
        system("./system_call");
    }
    else {
        wait(NULL);
        printf("child process finished. parent PID: %d\n", getpid());
    }

    return 0;
}
```

结果：外部程序 PID 比子进程大 1。  
原因：`system()` 内部再创建子进程（即孙进程）。

#### 调用方式二：`exec()`  

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/wait.h>

int main()
{
    pid_t pid;
    printf("parent process PID: %d\n", getpid());

    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed\n");
        return 1;
    }
    else if (pid == 0) {
        printf("child process PID: %d\n", getpid());
        execl("./system_call", "system_call", NULL);
        perror("execl failed"); 
    }
    else {
        wait(NULL);
        printf("child process finished. parent PID: %d\n", getpid());
    }

    return 0;
}
```

结果：外部程序 PID 与子进程相同。  
原因：`exec()` 替换当前进程镜像，PID 不变。

---

## 1.2 线程实验  

创建两个线程分别对同一共享变量进行加减操作：

```c
int count = 0;

void* thread_inc(void* arg) {
    for (int i = 0; i < 6000; i++) count++;
}

void* thread_dec(void* arg) {
    for (int i = 0; i < 6000; i++) count--;
}
```

理论上最终 `count = 0`。 
开始时使用同样的方法编译报错。原来是因为pthread 库不是Linux 系统默认的库，链接时需要使用库libpthread.a，所以使用pthread_create 创建线程时，要在编译中加-lpthread 参数。
运行gcc -o thread thread.c -lpthread  
成功，预期因为无同步机制，实际结果不确定。
<img width="760" height="504" alt="image" src="https://github.com/user-attachments/assets/529ada1d-1b4a-4516-b6ac-6dcb5e52bbf4" />
<img width="797" height="506" alt="image" src="https://github.com/user-attachments/assets/97cdf279-342d-45c5-a901-87ce234c0cc5" />
<img width="777" height="504" alt="image" src="https://github.com/user-attachments/assets/b8c4152b-1e62-4760-8c1e-ba5408894a24" />
<img width="780" height="507" alt="image" src="https://github.com/user-attachments/assets/367d3614-05df-4d28-8cd9-9aa915ec3afc" />

当循环次数为 6000 时，由于时间太短，线程切换很少，结果偶尔“看似正确”；  
当次数增至 60000 时，结果显著波动，不再等于 0。  
<img width="882" height="787" alt="image" src="https://github.com/user-attachments/assets/dcab8922-6c62-4712-a117-2b1b9295d045" />
<img width="797" height="762" alt="image" src="https://github.com/user-attachments/assets/1ef04413-f515-419c-9dee-ca6c4cdeecc5" />
<img width="825" height="757" alt="image" src="https://github.com/user-attachments/assets/4c2a1d75-0231-4588-bfe8-c23b60b8f19b" />
<img width="790" height="256" alt="image" src="https://github.com/user-attachments/assets/4f9ffc9f-e8a2-4f92-afc1-1f5336685f35" />
这是因为两个线程竞争访问共享的全局变量，导致每次运行的输出结果不一致。
#### 使用信号量与互斥锁  

- 加入信号量（PV 操作）后，输出稳定为 0；



- 使用互斥锁（`pthread_mutex_t`）后，同样得到正确结果。  

说明同步机制能有效避免竞态条件。

---

## 1.3 自旋锁实验  

完整代码：

```c
typedef struct {
    int flag;
} spinlock_t;

void spinlock_init(spinlock_t *lock) {
    lock->flag = 0;
}

void spinlock_lock(spinlock_t *lock) {
    while (__sync_lock_test_and_set(&lock->flag, 1)) {}
}

void spinlock_unlock(spinlock_t *lock) {
    __sync_lock_release(&lock->flag);
}
```

线程执行：

```c
for (int i = 0; i < 5000; ++i) {
    spinlock_lock(lock);
    shared_value++;
    spinlock_unlock(lock);
}
```

运行结果：  

```
Before: shared_value = 0
After: shared_value = 10000
```

无论运行多少次，结果恒定。  
说明自旋锁正确实现了线程互斥访问。

若去掉锁，则结果随机且明显偏离理论值。

---





