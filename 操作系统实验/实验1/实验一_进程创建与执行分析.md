# 实验一：进程创建与执行分析

---

## 1.1 运行课本程序

由于所给程序中使用了 `wait` 函数但缺少相应头文件，直接使用命令行编译会报错：

<div align="center">
  <img width="1685" height="174" alt="编译报错" src="https://github.com/user-attachments/assets/1bcf9792-5d23-467b-ac2e-23d05e967d4d" />
</div>

为方便观察输出，我在原程序的每个 `printf` 语句后都添加了换行符 `\n`，输出结果如下：

<div align="center">
 <img width="571" height="704" alt="输出结果1" src="https://github.com/user-attachments/assets/4727eafb-6309-4f92-b41c-38862ffada5b" />
</div>
<div align="center">
  <img width="524" height="704" alt="输出结果2" src="https://github.com/user-attachments/assets/1e31b4a8-2c92-4235-9636-cb6893d52cae" />
</div>

从结果可见，输出的顺序存在差异。按照理论推测（父进程等待子进程），输出应为：

```
child: pid = 0  
child: pid1 = 4890  
parent: pid = 4890  
parent: pid1 = 4889  
```

但在基于 OpenEuler 的 Deepin 虚拟机上运行时，输出顺序却变为：

<div align="center">
  <img width="526" height="684" alt="Deepin输出1" src="https://github.com/user-attachments/assets/cee314d3-27cc-4b1e-9c15-e1f550cf22ca" />
  <img width="536" height="676" alt="Deepin输出2" src="https://github.com/user-attachments/assets/b8e26388-a37d-462a-99bc-d1a70910f7ec" />
</div>

---

### 📖 调查与分析

经查阅资料，输出顺序的不确定性主要由 **操作系统调度器（Scheduler）** 决定。父子进程在创建后**并发执行**，操作系统根据当前 CPU 负载、调度策略（如 Linux 的 CFS - Completely Fair Scheduler）及随机中断因素决定哪个进程先执行。

三种典型情况如下：

1. **子进程先执行（常见）**
   ```
   child: pid = 0
   child: pid1 = 1234
   parent: pid = 1234
   parent: pid1 = 1233
   ```

2. **父进程先执行**
   ```
   parent: pid = 1234
   parent: pid1 = 1233
   child: pid = 0
   child: pid1 = 1234
   ```

3. **输出交错**
   ```
   child: pid = 0
   parent: pid = 1234
   child: pid1 = 1234
   parent: pid1 = 1233
   ```

> 由于缓冲区刷新与调度时机不同，`printf("\n")` 虽会触发行缓冲刷新，但仍可能出现交错输出。

---

### ✅ 去除换行后的结果

删除 `\n` 后，在华为云服务器上编译运行，输出顺序符合预期。  
代码如下：

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int main()
{
    pid_t pid, pid1;

    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) {
        pid1 = getpid();
        printf("child: pid = %d\n", pid);
        printf("child: pid1 = %d\n", pid1);
    }
    else {
        pid1 = getpid();
        printf("parent: pid = %d\n", pid);
        printf("parent: pid1 = %d\n", pid1);
        wait(NULL);
    }

    return 0;
}
```

<div align="center">
  <img width="1455" height="317" alt="pid输出结果" src="https://github.com/user-attachments/assets/7ae545c1-58a6-4562-bf4d-ccef3ea02a46" />
</div>

---

### 📊 统计运行结果

为探究调度规律，在华为云与虚拟机上各运行 10 次。结果显示：  
- 虚拟机中父进程先执行的概率更高；  
- 云服务器（多核高负载环境）中子进程先执行更常见。  

> **结论**：输出顺序具有随机性，与 CPU 调度策略密切相关。

---

## 1.2 添加全局变量的影响

补全头文件后，添加一个全局变量 `g`，代码如下：

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>

int g = 10;

int main()
{
    pid_t pid, pid1;
    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) {
        g += 5;
        pid1 = getpid();
        printf("child: pid = %d\n", pid);
        printf("child: pid1 = %d, g = %d\n", pid1, g);
    }
    else {
        g -= 5;
        pid1 = getpid();
        printf("parent: pid = %d\n", pid);
        printf("parent: pid1 = %d, g = %d\n", pid1, g);
        wait(NULL);
    }
    return 0;
}
```

<div align="center">
  <img width="585" height="176" alt="全局变量结果" src="https://github.com/user-attachments/assets/7c5d1165-f78a-4962-a23f-b0ccbba0ce45" />
</div>

**分析：**  
- 父子进程各自维护一份独立的变量副本。  
- `fork()` 发生时，变量 `g` 的值被复制到子进程中。  
- 因此，父进程 `g=5`，子进程 `g=15`，互不影响。

---

## 1.3 return 语句与变量变化

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>

int g = 10;

int main()
{
    pid_t pid, pid1;
    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) {
        g += 5;
        pid1 = getpid();
        printf("child: pid1 = %d, g(after +5) = %d\n", pid1, g);
    }
    else {
        g -= 5;
        pid1 = getpid();
        printf("parent: pid1 = %d, g(after -5) = %d\n", pid1, g);
        wait(NULL);
    }

    g *= 2;
    printf("pid %d: g(after *2) = %d\n", getpid(), g);

    return 0;
}
```

<div align="center">
  <img width="880" height="201" alt="return结果" src="https://github.com/user-attachments/assets/2bb70819-7433-43b9-929d-4b2aaca9595b" />
</div>

**分析：**  
每个进程独立执行 `g *= 2`，父子进程的结果互不影响。  
- 子进程：`(10+5)*2=30`  
- 父进程：`(10-5)*2=10`

---

## 1.4 调用外部程序：system 与 exec

### （1）system 调用

<div align="center">
  <img width="855" height="200" alt="system调用结果" src="https://github.com/user-attachments/assets/93637897-dd5c-4f84-a2e0-694a15cd1eb0" />
</div>

### （2）exec 调用

<div align="center">
  <img width="665" height="179" alt="exec调用结果" src="https://github.com/user-attachments/assets/09206440-12c2-41df-875d-4359e2737c30" />
</div>

**区别分析：**

| 函数 | 机制 | 特点 |
|------|------|------|
| `system()` | 调用 Shell 执行命令 | 父进程等待子进程完成 |
| `exec()` | 用新程序替换当前进程 | 不返回调用点，原程序被替代 |

---

## 🧩 实验总结

1. `fork()` 后父子进程并发执行，输出顺序受操作系统调度影响。  
2. 全局变量在 `fork()` 后被复制，各自独立。  
3. `wait()` 确保父进程等待子进程结束。  
4. `system()` 与 `exec()` 都可执行外部程序，但后者会替换当前进程。  
5. 输出差异、乱码问题与系统环境、编码及缓冲机制有关。

---

> 💡 **补充建议：**
> 若需在报告中展示代码运行统计，可用表格或折线图展示父/子进程先执行的频率分布，使结论更具说服力。
