
# 实验一：进程与线程实验报告  

---

## 1.1 进程实验  

### 1.1.1 `wait` 函数  

搭建好华为云服务器后开始实验，直接提取图片代码运行。由于所给程序使用了 `wait` 函数且缺少头文件，在使用命令行编译时会报错，如图所示：  

<div align="center">
  <img width="1685" height="174" src="https://github.com/user-attachments/assets/1bcf9792-5d23-467b-ac2e-23d05e967d4d" />
  <br>缺少头文件的运行结果
</div>

不过报错并不影响程序运行。为了方便观察，我在输出中加入了换行符 `\n`，输出结果如下图：  

<div align="center">
  <img width="571" height="704" src="https://github.com/user-attachments/assets/4727eafb-6309-4f92-b41c-38862ffada5b" />
  <img width="524" height="704" src="https://github.com/user-attachments/assets/1e31b4a8-2c92-4235-9636-cb6893d52cae" />
  <br>存在换行符的情况
</div>

结果显示每次输出分为四行，易于观察，但输出顺序并不固定。  

我认为在 `wait` 函数存在时，应该是子进程先输出，再由父进程输出，如下：  

```
child: pid = 0  
child: pid1 = 4890  
parent: pid = 4890  
parent: pid1 = 4889
```

但在安装了基于 OpenEuler 的 Deepin 系统虚拟机上运行相同程序时，结果却是父进程先输出：  

<div align="center">
  <img width="526" height="684" src="https://github.com/user-attachments/assets/cee314d3-27cc-4b1e-9c15-e1f550cf22ca" />
  <img width="536" height="676" src="https://github.com/user-attachments/assets/b8e26388-a37d-462a-99bc-d1a70910f7ec" />
  <br>在虚拟机上运行
</div>

#### 输出顺序分析  

存在三种典型情况：  

1. **子进程先执行（常见）**
   ```
   child: pid = 0
   child: pid1 = 1234
   parent: pid = 1234
   parent: pid1 = 1233
   ```
2. **父进程先执行打印（然后等待子进程）**
   ```
   parent: pid = 1234
   parent: pid1 = 1233
   child: pid = 0
   child: pid1 = 1234
   ```
3. **打印交错**
   ```
   child: pid = 0
   parent: pid = 1234
   child: pid1 = 1234
   parent: pid1 = 1233
   ```

输出顺序取决于操作系统调度算法。`fork()` 创建子进程后，父、子进程并发执行，调度器根据 CPU 负载和时钟中断等随机因素决定先后。

#### 去除换行符实验  

删除换行符后的代码如下：

```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid, pid1;
    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) {
        pid1 = getpid();
        printf("child: pid = %d", pid);
        printf("child: pid1 = %d", pid1);
    }
    else {
        pid1 = getpid();
        printf("parent: pid = %d", pid);
        printf("parent: pid1 = %d", pid1);
        wait(NULL);
    }
    return 0;
}
```

运行结果如下：

<div align="center">
  <img width="1455" height="317" src="https://github.com/user-attachments/assets/7ae545c1-58a6-4562-bf4d-ccef3ea02a46" />
  <br>删除 `\n` 后的运行结果
</div>

此时输出顺序稳定，符合预期。

#### 多次运行统计与分析  

多次运行结果显示：
- 子进程的 `pid` 恒为 0；
- 父进程的 `pid1` 比子进程大 1；
- 连续运行时 PID 逐次递增，差值通常为 2。

原因：
- `fork()` 在子进程中返回 0；
- 父进程中 `pid = 子进程PID`；
- `getpid()` 返回当前进程实际 PID；
- 系统分配 PID 时递增，差值受其他进程创建影响。

#### 去掉 `wait()` 对比  

<div align="center">
  <img width="1476" height="282" src="https://github.com/user-attachments/assets/9c1ab1ef-8303-4083-8cb5-979be170ef3e" />
  <br>去除 `wait()` 的结果
</div>

对比后发现：
- 有 `wait()`：父进程等待子进程结束，输出顺序稳定；
- 无 `wait()`：父子并发执行，输出顺序随机，甚至父进程先退出形成孤儿进程。

---

### 1.1.2 全局变量  

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <unistd.h>

int g = 10;

int main() {
    pid_t pid, pid1;
    pid = fork();

    if (pid < 0) {
        fprintf(stderr, "Fork Failed");
        return 1;
    }
    else if (pid == 0) {
        g += 5;
        pid1 = getpid();
        printf("child: pid1 = %d, g = %d\n", pid1, g);
    }
    else {
        g -= 5;
        pid1 = getpid();
        printf("parent: pid1 = %d, g = %d\n", pid1, g);
        wait(NULL);
    }
    return 0;
}
```

运行结果稳定：  
父进程 `g = 5`，子进程 `g = 15`。  
说明 `fork()` 后父子各自维护独立的变量副本。

#### 增加返回前操作  

```c
g *= 2;
printf("pid %d: g(after *2) = %d\n", getpid(), g);
```

运行结果：  
- 子进程 `(10 + 5) * 2 = 30`  
- 父进程 `(10 - 5) * 2 = 10`  

父子进程互不影响。

---

### 1.1.3 调用外部程序  

被调用程序 `system_call.c`：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("system_call PID: %d, 我的学号: 2233514228\n", getpid());
    return 0;
}
```

若输出含中文，终端编码不支持时会出现乱码。

#### 调用方式一：`system()`  

```c
pid = fork();
if (pid == 0) {
    printf("child process PID: %d\n", getpid());
    system("./system_call");
}
```

结果：外部程序 PID 比子进程大 1。  
原因：`system()` 内部再创建子进程（即孙进程）。

#### 调用方式二：`exec()`  

```c
pid = fork();
if (pid == 0) {
    printf("child process PID: %d\n", getpid());
    execl("./system_call", "system_call", NULL);
}
```

结果：外部程序 PID 与子进程相同。  
原因：`exec()` 替换当前进程镜像，PID 不变。

---

## 1.2 线程实验  

创建两个线程分别对同一共享变量进行加减操作：

```c
int count = 0;

void* thread_inc(void* arg) {
    for (int i = 0; i < 6000; i++) count++;
}

void* thread_dec(void* arg) {
    for (int i = 0; i < 6000; i++) count--;
}
```

理论上最终 `count = 0`。  
但由于无同步机制，实际结果不确定。

当循环次数为 6000 时，由于时间太短，线程切换很少，结果偶尔“看似正确”；  
当次数增至 60000 时，结果显著波动，不再等于 0。  

#### 使用信号量与互斥锁  

- 加入信号量（PV 操作）后，输出稳定为 0；
- 使用互斥锁（`pthread_mutex_t`）后，同样得到正确结果。  

说明同步机制能有效避免竞态条件。

---

## 1.3 自旋锁实验  

完整代码：

```c
typedef struct {
    int flag;
} spinlock_t;

void spinlock_init(spinlock_t *lock) {
    lock->flag = 0;
}

void spinlock_lock(spinlock_t *lock) {
    while (__sync_lock_test_and_set(&lock->flag, 1)) {}
}

void spinlock_unlock(spinlock_t *lock) {
    __sync_lock_release(&lock->flag);
}
```

线程执行：

```c
for (int i = 0; i < 5000; ++i) {
    spinlock_lock(lock);
    shared_value++;
    spinlock_unlock(lock);
}
```

运行结果：  

```
Before: shared_value = 0
After: shared_value = 10000
```

无论运行多少次，结果恒定。  
说明自旋锁正确实现了线程互斥访问。

若去掉锁，则结果随机且明显偏离理论值。

---

## 实验总结  

| 实验内容 | 主要问题 | 关键机制 | 实验结论 |
|-----------|-----------|-----------|-----------|
| 进程创建与 `wait` | 输出顺序不确定 | 调度机制、缓冲刷新 | 加入 `wait()` 后父进程等待子进程，输出稳定 |
| 全局变量 | 数据独立性 | 地址空间隔离 | 父子进程变量独立，互不影响 |
| 调用外部程序 | PID 关系 | `system()` vs `exec()` | `system` 创建新进程，`exec` 替换当前 |
| 多线程操作共享变量 | 竞态问题 | 同步与互斥机制 | 使用信号量/互斥锁可保证正确结果 |
| 自旋锁 | 资源竞争 | 原子操作、忙等待 | 正确实现互斥访问 |

---

**结论：**  
通过本实验，验证了进程与线程的创建与运行特性，理解了调度的随机性、内存空间的独立性以及同步机制的重要性。尤其在多线程场景中，通过信号量、互斥锁和自旋锁的对比实验，直观展示了不同同步手段的原理与效果。



