# 数字逻辑电路考试 Verilog 代码押题

## 引言

本文档为数字逻辑电路考试准备提供 Verilog 代码押题，覆盖组合逻辑、时序逻辑和状态机设计，适合复习和练习。每道题目包括题目描述、实现思路、完整代码（含 Testbench）、说明和可能变化形式。代码简洁、可综合，Testbench 便于验证。建议使用 ModelSim、Vivado 或 Quartus 运行代码，并手动推导逻辑以加深理解。

---

## 1. 4 位二选一多路选择器

### 题目描述

设计一个 4 位二选一多路选择器（MUX），输入为两个 4 位信号 `a` 和 `b`，选择信号 `sel`，输出为 4 位信号 `y`。当 `sel = 0` 时，`y = a`；当 `sel = 1` 时，`y = b`。

### 实现思路

- 使用 `assign` 语句或 `always @(*)` 实现组合逻辑。
- 通过条件运算符或 `if-else` 实现选择逻辑。
- Testbench 测试所有 `sel` 值和典型输入。

### 代码

```verilog
module mux_2to1_4bit (
    input wire [3:0] a, b,
    input wire sel,
    output wire [3:0] y
);
    assign y = sel ? b : a;
endmodule

// Testbench
module mux_2to1_4bit_tb;
    reg [3:0] a, b;
    reg sel;
    wire [3:0] y;
    
    mux_2to1_4bit dut (.a(a), .b(b), .sel(sel), .y(y));
    
    initial begin
        $monitor("time=%t, a=%b, b=%b, sel=%b, y=%b", $time, a, b, sel, y);
        a = 4'b1010; b = 4'b0011; sel = 0; #10;
        sel = 1; #10;
        a = 4'b1111; b = 4'b0000; sel = 0; #10;
        sel = 1; #10;
        $finish;
    end
endmodule
```

---


## 2. 4 位二进制计数器

### 题目描述

设计一个 4 位同步二进制计数器，输入为时钟 `clk` 和复位 `rst`，输出为 4 位计数值 `count`。计数器在时钟上升沿递增，复位时清零。

### 实现思路

- 使用 `always @(posedge clk)` 实现同步计数。
- 非阻塞赋值 `<=` 更新计数值。
- 同步复位：`rst = 1` 时清零。
- Testbench 生成时钟并测试复位和计数。

### 代码

```verilog
module counter_4bit (
    input wire clk, rst,
    output reg [3:0] count
);
    always @(posedge clk) begin
        if (rst)
            count <= 4'b0000;
        else
            count <= count + 1;
    end
endmodule

// Testbench
module counter_4bit_tb;
    reg clk, rst;
    wire [3:0] count;
    
    counter_4bit dut (.clk(clk), .rst(rst), .count(count));
    
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 10ns 时钟周期
    end
    
    initial begin
        $monitor("time=%t, rst=%b, count=%b", $time, rst, count);
        rst = 1; #10;
        rst = 0; #50;
        rst = 1; #10;
        rst = 0; #30;
        $finish;
    end
endmodule
```


---

## 3. 序列检测器

### 题目描述

设计一个 Moore 型状态机，检测输入序列 “1101” 的出现。输入为 `clk`、`rst` 和 1 位数据 `in`，输出为 `detect`（检测到序列时为 1）。状态机在时钟上升沿检查输入。

### 实现思路

- 定义状态：S0（初始）、S1（收到 1）、S2（收到 11）、S3（收到 110）、S4（收到 1101）。
- 分离状态寄存器、状态转移逻辑和输出逻辑。
- Moore 型：输出仅依赖状态。
- Testbench 测试典型序列。

### 代码

```verilog
module sequence_detector (
    input wire clk, rst, in,
    output reg detect
);
    parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;
    reg [2:0] state, next_state;
    
    // 状态寄存器
    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= S0;
        else
            state <= next_state;
    end
    
    // 状态转移逻辑
    always @(*) begin
        case (state)
            S0: next_state = in ? S1 : S0;
            S1: next_state = in ? S2 : S0;
            S2: next_state = in ? S2 : S3;
            S3: next_state = in ? S4 : S0;
            S4: next_state = in ? S1 : S0;
            default: next_state = S0;
        endcase
    end
    
    // 输出逻辑
    always @(*) begin
        detect = (state == S4);
    end
endmodule

// Testbench
module sequence_detector_tb;
    reg clk, rst, in;
    wire detect;
    
    sequence_detector dut (.clk(clk), .rst(rst), .in(in), .detect(detect));
    
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end
    
    initial begin
        $monitor("time=%t, rst=%b, in=%b, state=%b, detect=%b", $time, rst, in, dut.state, detect);
        rst = 1; in = 0; #10;
        rst = 0;
        // 测试序列 1101
        in = 1; #10;
        in = 1; #10;
        in = 0; #10;
        in = 1; #10;
        // 其他序列
        in = 0; #10;
        in = 1; #10;
        in = 1; #10;
        $finish;
    end
endmodule
```


---

## 4. 4 位比较器

### 题目描述

设计一个 4 位比较器，输入为两个 4 位信号 `a` 和 `b`，输出为 `eq`（相等）、`gt`（a > b）、`lt`（a < b）。当 `a = b` 时，`eq = 1`；当 `a > b` 时，`gt = 1`；当 `a < b` 时，`lt = 1`。

### 实现思路

- 使用 `assign` 语句实现比较逻辑。
- 确保输出互斥（仅一个输出为 1）。
- Testbench 测试典型输入对。

### 代码

```verilog
module comparator_4bit (
    input wire [3:0] a, b,
    output wire eq, gt, lt
);
    assign eq = (a == b);
    assign gt = (a > b);
    assign lt = (a < b);
endmodule

// Testbench
module comparator_4bit_tb;
    reg [3:0] a, b;
    wire eq, gt, lt;
    
    comparator_4bit dut (.a(a), .b(b), .eq(eq), .gt(gt), .lt(lt));
    
    initial begin
        $monitor("a=%b, b=%b, eq=%b, gt=%b, lt=%b", a, b, eq, gt, lt);
        a = 4'd5; b = 4'd5; #10;
        a = 4'd7; b = 4'd3; #10;
        a = 4'd2; b = 4'd9; #10;
        $finish;
    end
endmodule
```


---


## 5. 8 位移位寄存器

### 题目描述

设计一个 8 位串行输入并行输出移位寄存器，输入为 `clk`、`rst` 和串行数据 `data_in`，输出为 8 位并行数据 `data_out`。数据在时钟上升沿左移，复位时清零。

### 实现思路

- 使用 `reg [7:0]` 存储数据。
- 在 `always @(posedge clk)` 中实现移位逻辑。
- 同步复位清零。
- Testbench 测试移位和复位。

### 代码

```verilog
module shift_register_8bit (
    input wire clk, rst, data_in,
    output reg [7:0] data_out
);
    always @(posedge clk) begin
        if (rst)
            data_out <= 8'b0;
        else
            data_out <= {data_out[6:0], data_in};
    end
endmodule

// Testbench
module shift_register_8bit_tb;
    reg clk, rst, data_in;
    wire [7:0] data_out;
    
    shift_register_8bit dut (.clk(clk), .rst(rst), .data_in(data_in), .data_out(data_out));
    
    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end
    
    initial begin
        $monitor("time=%t, rst=%b, data_in=%b, data_out=%b", $time, rst, data_in, data_out);
        rst = 1; data_in = 0; #10;
        rst = 0;
        data_in = 1; #20;
        data_in = 0; #10;
        data_in = 1; #10;
        rst = 1; #10;
        rst = 0; #20;
        $finish;
    end
endmodule
```
